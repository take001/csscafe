(function() {
  var Program, SequenceNumber, SequenceNumberMax, fs, log, path, utils,
    hasProp = {}.hasOwnProperty;

  fs = require('fs');

  path = require('path');

  utils = exports;

  utils.Program = Program = path.basename(process.argv[1]);

  SequenceNumberMax = 100 * 1024 * 1024;

  SequenceNumber = 0;

  utils.getNextSequenceNumber = function(g) {
    SequenceNumber++;
    if (SequenceNumber > SequenceNumberMax) {
      SequenceNumber = 0;
    }
    return SequenceNumber;
  };

  utils.trim = function(string) {
    return string.replace(/(^\s+)|(\s+$)/g, '');
  };

  utils.log = log = function(message) {
    var date, time;
    date = new Date();
    time = date.toISOString();
    return console.log(time + " " + Program + ": " + message);
  };

  utils.logVerbose = function(message) {
    var ref;
    if (!(utils != null ? (ref = utils.options) != null ? ref.verbose : void 0 : void 0)) {
      return;
    }
    return log(message);
  };

  utils.logDebug = function(message) {
    var ref;
    if (!(utils != null ? (ref = utils.options) != null ? ref.debug : void 0 : void 0)) {
      return;
    }
    return log(message);
  };

  utils.exit = function(message) {
    log(message);
    return process.exit(1);
  };

  utils.pitch = function(message) {
    log(message);
    throw message;
  };

  utils.setOptions = function(options) {
    return utils.options = options;
  };

  utils.ensureInteger = function(value, message) {
    var newValue;
    newValue = parseInt(value);
    if (isNaN(newValue)) {
      utils.exit(message + ": '" + value + "'");
    }
    return newValue;
  };

  utils.ensureString = function(value, message) {
    if (typeof value !== 'string') {
      utils.exit(message + ": '" + value + "'");
    }
    return value;
  };

  utils.ensureBoolean = function(value, message) {
    var newValue, uValue;
    uValue = value.toString().toUpperCase();
    newValue = null;
    switch (uValue) {
      case 'TRUE':
        newValue = true;
        break;
      case 'FALSE':
        newValue = false;
    }
    if (typeof newValue !== 'boolean') {
      utils.exit(message + ": '" + value + "'");
    }
    return newValue;
  };

  utils.setNamesForClass = function(aClass) {
    var key, ref, results, val;
    for (key in aClass) {
      if (!hasProp.call(aClass, key)) continue;
      val = aClass[key];
      if (typeof val === "function") {
        val.signature = aClass.name + "::" + key;
        val.displayName = val.signature;
        val.name = val.signature;
      }
    }
    ref = aClass.prototype;
    results = [];
    for (key in ref) {
      if (!hasProp.call(ref, key)) continue;
      val = ref[key];
      if (typeof val === "function") {
        val.signature = aClass.name + "." + key;
        val.displayName = val.signature;
        results.push(val.name = val.signature);
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  utils.registerClass = function(aClass) {
    utils.setNamesForClass(aClass);
    return aClass;
  };

  utils.alignLeft = function(string, length) {
    while (string.length < length) {
      string = string + " ";
    }
    return string;
  };

  utils.alignRight = function(string, length) {
    while (string.length < length) {
      string = " " + string;
    }
    return string;
  };

  utils.fileExistsSync = function(name) {
    if (fs.existsSync) {
      return fs.existsSync(name);
    }
    return path.existsSync(name);
  };

  Error.prepareStackTrace = function(error, structuredStackTrace) {
    var callSite, file, func, funcName, i, j, len, len1, line, longestFile, longestLine, result;
    result = [];
    result.push("---------------------------------------------------------");
    result.push("error: " + error);
    result.push("---------------------------------------------------------");
    result.push("stack: ");
    longestFile = 0;
    longestLine = 0;
    for (i = 0, len = structuredStackTrace.length; i < len; i++) {
      callSite = structuredStackTrace[i];
      file = callSite.getFileName();
      line = callSite.getLineNumber();
      file = path.basename(file);
      line = "" + line;
      if (file.length > longestFile) {
        longestFile = file.length;
      }
      if (line.length > longestLine) {
        longestLine = line.length;
      }
    }
    for (j = 0, len1 = structuredStackTrace.length; j < len1; j++) {
      callSite = structuredStackTrace[j];
      func = callSite.getFunction();
      file = callSite.getFileName();
      line = callSite.getLineNumber();
      file = path.basename(file);
      line = "" + line;
      file = utils.alignRight(file, longestFile);
      line = utils.alignLeft(line, longestLine);
      funcName = func.displayName || func.name || callSite.getFunctionName();
      callSite.getMethodName();
      '???';
      if (funcName === "Module._compile") {
        result.pop();
        result.pop();
        break;
      }
      result.push("   " + file + ":" + line + " - " + funcName + "()");
    }
    return result.join("\n");
  };

}).call(this);
